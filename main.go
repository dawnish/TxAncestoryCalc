package main

import (
  "fmt"
  "sort"
  "strconv"
  "net/http"
  "io/ioutil"
  "encoding/json"

  progressBar "txancestorycalc/progressbar"
)

type AutoGenerated struct {
	Txid     string `json:"txid"`
	Version  int    `json:"version"`
	Locktime int    `json:"locktime"`
	Vin      []Vin  `json:"vin"`
	Vout     []Vout `json:"vout"`
	Size     int    `json:"size"`
	Weight   int    `json:"weight"`
	Fee      int    `json:"fee"`
	Status   Status `json:"status"`
}
type Prevout struct {
	Scriptpubkey        string `json:"scriptpubkey"`
	ScriptpubkeyAsm     string `json:"scriptpubkey_asm"`
	ScriptpubkeyType    string `json:"scriptpubkey_type"`
	ScriptpubkeyAddress string `json:"scriptpubkey_address"`
	Value               int    `json:"value"`
}
type Vin struct {
	Txid         string  `json:"txid"`
	Vout         int     `json:"vout"`
	Prevout      Prevout `json:"prevout"`
	Scriptsig    string  `json:"scriptsig"`
	ScriptsigAsm string  `json:"scriptsig_asm"`
	IsCoinbase   bool    `json:"is_coinbase"`
	Sequence     int64   `json:"sequence"`
}
type Vout struct {
	Scriptpubkey        string `json:"scriptpubkey"`
	ScriptpubkeyAsm     string `json:"scriptpubkey_asm"`
	ScriptpubkeyType    string `json:"scriptpubkey_type"`
	ScriptpubkeyAddress string `json:"scriptpubkey_address"`
	Value               int    `json:"value"`
}
type Status struct {
	Confirmed   bool   `json:"confirmed"`
	BlockHeight int    `json:"block_height"`
	BlockHash   string `json:"block_hash"`
	BlockTime   int    `json:"block_time"`
}

type AncestorCalc struct {
	ParentTxid string
	TxCount   int
}

type AncestorCalcList []AncestorCalc

func main() {
	blockid := "000000000000000000076c036ff5119e5a5a74df77abf64203473364509f7732"
	url := "https://blockstream.info/api/block/" + blockid + "/txids"
	method := "GET"
  
	client := &http.Client {
	}
	req, err := http.NewRequest(method, url, nil)
  
	if err != nil {
	  fmt.Println(err)
	  return
	}
	res, err := client.Do(req)
	if err != nil {
	  fmt.Println(err)
	  return
	}
	defer res.Body.Close()
  
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
	  fmt.Println(err)
	  return
	}
	// fmt.Println(string(body))

	var data_obj []string

	jsonErr := json.Unmarshal(body, &data_obj)
	if jsonErr != nil {
		fmt.Println(jsonErr)
	}

	txids := make(map[string][]string)
	fmt.Printf("Total Transactions for blockid %s: %d \n", blockid, len(data_obj))
	for _, value := range data_obj {
		// fmt.Printf("txid[%d]: %s \n", key, value)
		txids[value] = make([]string, 0)
		// if (key == 100) {
		// 	break
		// }
	}
	iterCount := len(txids) / 25
	if (((iterCount * 25) - len(txids)) > 0) {
		iterCount++
	}
	// fmt.Printf("TxCount: %d, NumOfIterations: %d \n", len(txids), iterCount)

	getTransactions(txids, blockid, iterCount)
	
	ancestCalc := make([]AncestorCalc, len(txids))
	i :=0
	for parentTxid, childTxs := range txids {
		// fmt.Printf("ParentTx[%s]: %d \n", parentTxid, len(childTxs))
		uniqueTxs := removeDuplicateTxs(childTxs)
		txids[parentTxid] = uniqueTxs
		ancestCount := len(uniqueTxs)
		if (ancestCount > 0) {
			ancestCalc[i] = AncestorCalc{ parentTxid, ancestCount }
			// fmt.Printf("ParentTx[%s]: %d \n", parentTxid, len(childTxs))
			i++
		}
	}

	sort.SliceStable(ancestCalc, func(i, j int) bool {
		return ancestCalc[i].TxCount > ancestCalc[j].TxCount
	})
	
	for _, k := range ancestCalc {
		if (k.TxCount > 0) {
			fmt.Printf("ParentTx[%v]\t%v\n", k.ParentTxid, k.TxCount)
		}
    }

}

func getTransactions(txids map[string][]string, blockid string, iterCount int) {
	var bar progressBar.Bar
	bar.NewOption(0, int64(iterCount-1))
	for idx :=  0; idx < iterCount; idx++ {
		startIndex := strconv.Itoa(idx*25)
		url := "https://blockstream.info/api/block/"+ blockid + "/txs/" + startIndex
		method := "GET"

		client := &http.Client {
		}
		req, err := http.NewRequest(method, url, nil)

		if err != nil {
			fmt.Println(err)
			return
		}
		res, err := client.Do(req)
		if err != nil {
			fmt.Println(err)
			return
		}
		defer res.Body.Close()

		body, err := ioutil.ReadAll(res.Body)
		if err != nil {
			fmt.Println(err)
			return
		}
		// fmt.Println(string(body))

		data_obj := []AutoGenerated{}
		jsonErr := json.Unmarshal(body, &data_obj)
		if jsonErr != nil {
			fmt.Println(jsonErr)
		}

		for _, dataInput := range data_obj {
			// fmt.Printf("ChildTrxId[%d]: %v \n", dk, dataInput.Txid)
			for _, parentInput := range dataInput.Vin {
				// fmt.Println(dataInput.Vin)
				if _, ok := txids[parentInput.Txid]; ok {
					txids[parentInput.Txid] = append(txids[parentInput.Txid], dataInput.Txid)
					// fmt.Printf("txid[%d]: %v \n", vk, parentInput.Txid)
				}
			}
		}
		
		bar.Play(int64(idx))
	}

	bar.Finish()
}	

func removeDuplicateTxs(childTxs []string) []string {
    allKeys := make(map[string]bool)
    list := []string{}
    for _, item := range childTxs {
        if _, value := allKeys[item]; !value {
            allKeys[item] = true
            list = append(list, item)
        }
    }
    return list
}