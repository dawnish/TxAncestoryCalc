package main

import (
  "fmt"
  "sort"
  "net/http"
  "io/ioutil"
  "encoding/json"

  progressBar "txancestorycalc/progressbar"
)

type AutoGenerated struct {
	Txid     string `json:"txid"`
	Version  int    `json:"version"`
	Locktime int    `json:"locktime"`
	Vin      []Vin  `json:"vin"`
	Vout     []Vout `json:"vout"`
	Size     int    `json:"size"`
	Weight   int    `json:"weight"`
	Fee      int    `json:"fee"`
	Status   Status `json:"status"`
}
type Prevout struct {
	Scriptpubkey        string `json:"scriptpubkey"`
	ScriptpubkeyAsm     string `json:"scriptpubkey_asm"`
	ScriptpubkeyType    string `json:"scriptpubkey_type"`
	ScriptpubkeyAddress string `json:"scriptpubkey_address"`
	Value               int    `json:"value"`
}
type Vin struct {
	Txid         string  `json:"txid"`
	Vout         int     `json:"vout"`
	Prevout      Prevout `json:"prevout"`
	Scriptsig    string  `json:"scriptsig"`
	ScriptsigAsm string  `json:"scriptsig_asm"`
	IsCoinbase   bool    `json:"is_coinbase"`
	Sequence     int64   `json:"sequence"`
}
type Vout struct {
	Scriptpubkey        string `json:"scriptpubkey"`
	ScriptpubkeyAsm     string `json:"scriptpubkey_asm"`
	ScriptpubkeyType    string `json:"scriptpubkey_type"`
	ScriptpubkeyAddress string `json:"scriptpubkey_address"`
	Value               int    `json:"value"`
}
type Status struct {
	Confirmed   bool   `json:"confirmed"`
	BlockHeight int    `json:"block_height"`
	BlockHash   string `json:"block_hash"`
	BlockTime   int    `json:"block_time"`
}

type AncestorCalc struct {
	ParentTxid string
	TxCount   int
}

type AncestorCalcList []AncestorCalc

func main() {
	blockid := "000000000000000000076c036ff5119e5a5a74df77abf64203473364509f7732"
	url := "https://blockstream.info/api/block/" + blockid + "/txids"
	method := "GET"
  
	client := &http.Client {
	}
	req, err := http.NewRequest(method, url, nil)
  
	if err != nil {
	  fmt.Println(err)
	  return
	}
	res, err := client.Do(req)
	if err != nil {
	  fmt.Println(err)
	  return
	}
	defer res.Body.Close()
  
	body, err := ioutil.ReadAll(res.Body)
	if err != nil {
	  fmt.Println(err)
	  return
	}
	// fmt.Println(string(body))

	var data_obj []string

	jsonErr := json.Unmarshal(body, &data_obj)
	if jsonErr != nil {
		fmt.Println(jsonErr)
	}

	txids := make(map[string][]string)
	fmt.Println("Total Transactions for blockid %s: %d", blockid, len(data_obj))
	for _, value := range data_obj {
		// fmt.Printf("txid[%d]: %s \n", key, value)
		txids[value] = make([]string, 0)
		// if (key == 100) {
		// 	break
		// }
	}
	getTransactions(txids)
	ancestCalc := make([]AncestorCalc, len(txids))
	i :=0
	for parentTxid, childTxs := range txids {
		// fmt.Printf("ParentTx[%s]: %d \n", parentTxid, len(childTxs))
		uniqueTxs := removeDuplicateTxs(childTxs)
		txids[parentTxid] = uniqueTxs
		ancestCount := len(uniqueTxs)
		if (ancestCount > 0) {
			ancestCalc[i] = AncestorCalc{ parentTxid, ancestCount }
			// fmt.Printf("ParentTx[%s]: %d \n", parentTxid, len(childTxs))
			i++
		}
	}

	sort.SliceStable(ancestCalc, func(i, j int) bool {
		return ancestCalc[i].TxCount > ancestCalc[j].TxCount
	})
	
	for _, k := range ancestCalc {
		if (k.TxCount > 0) {
			fmt.Printf("ParentTx[%v]\t%v\n", k.ParentTxid, k.TxCount)
		}
    }

}

func getTransactions(txids map[string][]string) {
	var bar progressBar.Bar
	bar.NewOption(0, int64(len(txids) - 1))
	progVal := 0
	for childTxid, _ := range txids {

		// url := "https://blockstream.info/api/tx/ee8d5722769181cf1dfa9b0fc199c60b2994e3e839d610cead3029bad58cdaef"
		url := "https://blockstream.info/api/tx/" + childTxid
		method := "GET"

		client := &http.Client {
		}
		req, err := http.NewRequest(method, url, nil)

		if err != nil {
			fmt.Println(err)
			return
		}
		res, err := client.Do(req)
		if err != nil {
			fmt.Println(err)
			return
		}
		defer res.Body.Close()

		body, err := ioutil.ReadAll(res.Body)
		if err != nil {
			fmt.Println(err)
			return
		}
		// fmt.Println(string(body))

		data_obj := AutoGenerated{}
		jsonErr := json.Unmarshal(body, &data_obj)
		if jsonErr != nil {
			fmt.Println(jsonErr)
		}

		for _, parentInput := range data_obj.Vin {
			// fmt.Println(data_obj.Vin)
			if _, ok := txids[parentInput.Txid]; ok {
				txids[parentInput.Txid] = append(txids[parentInput.Txid], childTxid)
			}
			// fmt.Printf("txid[%d]: %v \n", key, value.Txid)
		}
		bar.Play(int64(progVal))
		progVal++
	}

	bar.Finish()
}	

func removeDuplicateTxs(childTxs []string) []string {
    allKeys := make(map[string]bool)
    list := []string{}
    for _, item := range childTxs {
        if _, value := allKeys[item]; !value {
            allKeys[item] = true
            list = append(list, item)
        }
    }
    return list
}